<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>心得 on Chaoxin</title>
    <link>http://chaoxin.site/tags/%E5%BF%83%E5%BE%97/</link>
    <description>Recent content in 心得 on Chaoxin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-ch</language>
    <copyright>©2022 Chaoxin.</copyright>
    <lastBuildDate>Sat, 04 Jun 2022 14:28:33 +0800</lastBuildDate>
    
        <atom:link href="http://chaoxin.site/tags/%E5%BF%83%E5%BE%97/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>《Kubernetes in Action》读书笔记第一章：Kubernetes介绍</title>
      <link>http://chaoxin.site/post/kubernates_in_action_1/</link>
      <pubDate>Sun, 12 Feb 2023 17:08:21 +0800</pubDate>
      
      <guid>http://chaoxin.site/post/kubernates_in_action_1/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://cdn.nlark.com/yuque/0/2023/png/29308157/1676190017059-a4abf2f9-3155-4913-a529-bbe2bc1acac6.png&#34;target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;https://cdn.nlark.com/yuque/0/2023/png/29308157/1676190017059-a4abf2f9-3155-4913-a529-bbe2bc1acac6.png&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;ne&amp;amp;taskId=ue2b47874-d2c1-4aa7-a778-f848ab1a265&amp;amp;title=&amp;amp;width=698.4&lt;/p&gt;
&lt;h2 id=&#34;1从单体应用到微服务&#34;&gt;1.从单体应用到微服务&lt;/h2&gt;
&lt;p&gt;运行一个单体应用，通常需要一台能为整个应用提供足够资源的高性能服务器。为了应对不断增长的系统负荷，我们需要通过增加CPU、内存或其他系统资源的方式来对服务器做垂直扩展，或者增加更多的跑这些应用程序的服务器的做水平扩展。
垂直扩展不需要应用程序做任何变化，但是成本很快会越来越高，并且通常会有瓶颈。如果是水平扩展，就可能需要应用程序代码做比较大的改动，有时候甚至是不可行的，比如系统的一些组件非常难于甚至不太可能去做水平扩展（像关系型数据库）。如果单体应用的任何一个部分不能扩展，整个应用就不能扩展，除非我们想办法把它拆分开。
这些问题迫使我们将复杂的大型单体应用，拆分为小的可独立部署的微服务组件。每个微服务以独立的进程运行，并通过简单且定义良好的接口（API）与其他的微服务通信。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://cdn.nlark.com/yuque/0/2023/png/29308157/1676190017059-a4abf2f9-3155-4913-a529-bbe2bc1acac6.png&#34;
        alt=&#34;image.png&#34;/&gt;&lt;/p&gt;
&lt;p&gt;像大多数情况一样，微服务也有缺点。当组件数量增加时，部署相关的决定就变得越来越困难。因为不仅组件部署的组合数在增加，而且组件间依赖的组合数也在以更大的因素增加。
部署动态链接的应用需要不同版本的共享库，或者需要其他特殊环境，在生产服务器部署并管理这种应用很快会成为运维团队的噩梦。需要在同一个主机上部署的组件数量越大，满足这些组件的所有需求就越难。
&lt;img  src=&#34;https://cdn.nlark.com/yuque/0/2023/png/29308157/1675873518987-07edd6d4-5f9f-4ce4-af49-4b5eb0f3ca0a.png&#34;
        alt=&#34;image.png&#34;/&gt;
不管你同时开发和部署多少个独立组件，开发和运维团队总是需要解决的一个最大的问题是程序运行环境的差异性，这种巨大差异不仅存在于开发环境与生产环境之间，甚至存在于各个生产机器之间。另外一个无法避免的事实是生产机器的环境会随着时间的推移而变化。这些差异性存在于从硬件到操作系统再到每台机器的可用库上。
生产环境是由运维团队管理的，而开发者常常比较关心他们自己的开发环境。这两组人对系统管理的理解程度是不同的，这个理解偏差导致两个环境的系统有较大的差异，系统管理员更重视保持系统更新最近的安全补丁，而大多数开发者则并不太关心。&lt;/p&gt;
&lt;h2 id=&#34;2为应用程序提供一个一致的环境&#34;&gt;2.为应用程序提供一个一致的环境&lt;/h2&gt;
&lt;p&gt;在最近几年中，我们看到了应用在开发流程和生产运维流程中的变化。在过去，开发团队的任务是创建应用并交付给运维团队，然后运维团队部署应用并使它运行。但是现在，公司都意识到，让同一个团队参与应用的开发、部署、运维的整个生命周期更好这意味着开发者、QA和运维团队彼此之间的合作需要贯穿整个流程。这种实践被称为DevOps。
为了频繁地发布应用，就需要简化你的部署流程。理想的状态是开发人员能够自己部署应用上线，而不需要交付给运维人员操作。但是，部署应用往往需要具备对数据中心底层设备和硬件架构的理解。开发人员却通常不知道或者不想知道这些细节。
正如你所看到的，Kubernetes能让我们实现所有这些想法。通过对实际硬件做抽象，然后将自身暴露成一个平台，用于部署和运行应用程序。它允许开发者自己配置和部署应用程序，而不需要系统管理员的任何帮助，让系统管理员聚焦于保持底层基础设施运转正常的同时，不需要关注实际运行在平台上的应用程序。&lt;/p&gt;
&lt;h2 id=&#34;3-容器技术&#34;&gt;3. 容器技术&lt;/h2&gt;
&lt;p&gt;和虚拟机比较，容器更加轻量级，它允许在相同的硬件上运行更多数量的组件。主要是因为每个虚拟机需要运行自己的一组系统进程，这就产生了除组件进程消耗以外的额外计算资源损耗。从另一方面说，一个容器仅仅是运行在宿主机上被隔离的单个进程，仅消耗应用容器消耗的资源，不会有其他进程的开销。
&lt;img  src=&#34;https://cdn.nlark.com/yuque/0/2023/png/29308157/1675873968367-bcdaa7e6-cfc5-4e57-83b1-f3febf90ab79.png&#34;
        alt=&#34;image.png&#34;/&gt;
当你在一台主机上运行三个虚拟机的时候，你拥有了三个完全分离的操作系统，它们运行并共享一台裸机。在那些虚拟机之下是宿主机的操作系统与一个管理程序，它将物理硬件资源分成较小部分的虚拟硬件资源，从而被每个虚拟机里的操作系统使用。运行在那些虚拟机里的应用程序会执行虚拟机操作系统的系统调用，然后虚拟机内核会通过管理程序在宿主机上的物理来CPU执行x86指令。
注意存在两种类型的管理程序。第一种类型的管理程序不会使用宿主机OS，而第二种类型的会。
多个容器则会完全执行运行在宿主机上的同一个内核的系统调用，此内核是唯一一个在宿主机操作系统上执行x86指令的内核。CPU也不需要做任何对虚拟机能做那样的虚拟化（如图1.5所示）。
&lt;img  src=&#34;https://cdn.nlark.com/yuque/0/2023/png/29308157/1675874057823-a417b525-e975-4bba-9f63-a0491c861af7.png&#34;
        alt=&#34;image.png&#34;/&gt;
那容器到底是怎样隔离它们的。有两个机制可用：
第一个是Linux命名空间，它使每个进程只看到它自己的系统视图（文件、进程、网络接口、主机名等）；
第二个是Linux控制组（cgroups），它限制了进程能使用的资源量（CPU、内存、网络带宽等）。
用Linux命名空间隔离进程默认情况下，每个Linux系统最初仅有一个命名空间。所有系统资源（诸如文件系统、用户ID、网络接口等）属于这一个命名空间。但是你能创建额外的命名空间，以及在它们之间组织资源。对于一个进程，可以在其中一个命名空间中运行它。
进程将只能看到同一个命名空间下的资源。当然，会存在多种类型的多个命名空间，所以一个进程不单单只属于某一个命名空间，而属于每个类型的一个命名空间。存在以下类型的命名空间：Mount（mnt）ProcessID（pid）Network（net）Inter-processcommunicaion（ipd）UTSUserID（user）每种命名空间被用来隔离一组特定的资源。
现在你应该已经了解命名空间是如何隔离容器中运行的应用的。限制进程的可用资源另外的隔离性就是限制容器能使用的系统资源。这通过cgroups来实现。cgroups是一个Linux内核功能，它被用来限制一个进程或者一组进程的资源使用。一个进程的资源（CPU、内存、网络带宽等）使用量不能超出被分配的量。这种方式下，进程不能过分使用为其他进程保留的资源，这和进程运行在不同的机器上是类似的。&lt;/p&gt;
&lt;p&gt;Docker是第一个使容器成为主流的容器平台。Docker本身并不提供进程隔离，实际上容器隔离是在Linux内核之上使用诸如Linux命名空间和cgroups之类的内核特性完成的，Docker仅简化了这些特性的使用。
尽管容器技术已经出现很久，却是随着Docker容器平台的出现而变得广为人知。Docker是第一个使容器能在不同机器之间移植的系统。它不仅简化了打包应用的流程，也简化了打包应用的库和依赖，甚至整个操作系统的文件系统能被打包成一个简单的可移植的包，这个包可以被用来在任何其他运行Docker的机器上使用。
例如，如果你用整个红帽企业版Linux（RHEL）的文件打包了你的应用程序，不管在装有Fedora的开发机上运行它，还是在装有Debian或者其他Linux发行版的服务器上运行它，应用程序都认为它运行在RHEL中。只是内核可能不同。
&lt;img  src=&#34;https://cdn.nlark.com/yuque/0/2023/png/29308157/1675874638346-b8492e88-886e-4bd0-be77-a5be7e0653c4.png&#34;
        alt=&#34;image.png&#34;/&gt;&lt;/p&gt;
&lt;p&gt;前面已经说过Docker镜像由多层构成。不同镜像可能包含完全相同的层，因为这些Docker镜像都是基于另一个镜像之上构建的，不同的镜像都能使用相同的父镜像作为它们的基础镜像。这提升了镜像在网络上的分发效率，当传输某个镜像时，因为相同的层已被之前的镜像传输，那么这些层就不需要再被传输。
层不仅使分发更高效，也有助于减少镜像的存储空间。每一层仅被存一次，当基于相同基础层的镜像被创建成两个容器时，它们就能够读相同的文件。但是如果其中一个容器写入某些文件，另外一个是无法看见文件变更的。因此，即使它们共享文件，仍然彼此隔离。这是因为容器镜像层是只读的。容器运行时，一个新的可写层在镜像层之上被创建。容器中进程写入位于底层的。
&lt;img  src=&#34;https://cdn.nlark.com/yuque/0/2023/png/29308157/1676191006849-7bf3c5d2-c0db-4f10-9d02-d40ceb44d9c1.png&#34;
        alt=&#34;image.png&#34;/&gt;
理论上，一个容器镜像能运行在任何一个运行Docker的机器上。但有一个小警告——一个关于运行在一台机器上的所有容器共享主机Linux内核的警告。如果一个容器化的应用需要一个特定的内核版本，那它可能不能在每台机器上都工作。如果一台机器上运行了一个不匹配的Linux内核版本，或者没有相同内核模块可用，那么此应用就不能在其上运行。
虽然容器相比虚拟机轻量许多，但也给运行于其中的应用带来了一些局限性。虚拟机没有这些局限性，因为每个虚拟机都运行自己的内核。
还不仅是内核的问题。一个在特定硬件架构之上编译的容器化应用，只能在有相同硬件架构的机器上运行。不能将一个x86架构编译的应用容器化后，又期望它能运行在ARM架构的机器上。你仍然需要一台虚拟机来做这件事情。&lt;/p&gt;
&lt;h2 id=&#34;4-kubernetes介绍&#34;&gt;4. Kubernetes介绍&lt;/h2&gt;
&lt;p&gt;主节点，它承载着Kubernetes控制和管理整个集群系统的控制面板工作节点，它们运行用户实际部署的应用
&lt;img  src=&#34;https://cdn.nlark.com/yuque/0/2023/png/29308157/1675875307985-0679e6ac-4134-45b6-99b4-a9f8fc6df43e.png&#34;
        alt=&#34;image.png&#34;/&gt;
控制面板控制面板用于控制集群并使它工作。它包含多个组件，组件可以运行在单个主节点上或者通过副本分别部署在多个主节点以确保高可用性。这些组件是：
KubernetesAPI服务器，你和其他控制面板组件都要和它通信
Scheculer，它调度你的应用（为应用的每个可部署组件分配一个工作节点）
ControllerManager，它执行集群级别的功能，如复制组件、持续跟踪工作节点、处理节点失败等
etcd，一个可靠的分布式数据存储，它能持久化存储集群配置控制面板的组件持有并控制集群状态，但是它们不运行你的应用程序。这是由工作节点完成的。
工作节点工作节点是运行容器化应用的机器。运行、监控和管理应用服务的任务是由以下组件完成的：Docker、rtk或其他的容器类型Kubelet，它与API服务器通信，并管理它所在节点的容器KubernetesServiceProxy（kube-proxy），它负责组件之间的负载均衡网络流量
&lt;img  src=&#34;https://cdn.nlark.com/yuque/0/2023/png/29308157/1676191160468-3df4e608-1f07-4d10-a4ad-9cc172b53447.png&#34;
        alt=&#34;image.png&#34;/&gt;&lt;/p&gt;
&lt;p&gt;为了在Kubernetes中运行应用，首先需要将应用打包进一个或多个容器镜像，再将那些镜像推送到镜像仓库，然后将应用的描述发布到KubernetesAPI服务器。
当API服务器处理应用的描述时，调度器调度指定组的容器到可用的工作节点上，调度是基于每组所需的计算资源，以及调度时每个节点未分配的资源。然后，那些节点上的Kubelet指示容器运行时（例如Docker）拉取所需的镜像并运行容器。仔细看图1.10以更好地理解如何在Kubernetes中部署应用程序。应用描述符列出了四个容器，并将它们分为三组。前两个pod只包含一个容器，而最后一个包含两个。这意味着两个容器都需要协作运行，不应该相互隔离。在每个pod旁边，还可以看到一个数字，表示需要并行运行的每个pod的副本数量。
在向Kubernetes提交描述符之后，它将把每个pod的指定副本数量调度到可用的工作节点上。节点上的Kubelets将告知Docker从镜像仓库中拉取容器镜像并运行容器。保持容器运行一旦应用程序运行起来，Kubernetes就会不断地确认应用程序的部署状态始终与你提供的描述相匹配。例如，如果你指出你需要运行五个web服务器实例，那么Kubernetes总是保持正好运行五个实例。如果实例之一停止了正常工作，比如当进程崩溃或停止响应时，Kubernetes将自动重启它。
同理，如果整个工作节点死亡或无法访问，Kubernetes将为在故障节点上运行的所有容器选择新节点，并在新选择的节点上运行它们。
为了让客户能够轻松地找到提供特定服务的容器，可以告诉Kubernetes哪些容器提供相同的服务，而Kubernetes将通过一个静态IP地址暴露所有容器，并将该地址暴露给集群中运行的所有应用程序。这是通过环境变量完成的，但是客户端也可以通过良好的DNS查找服务IP。kube-proxy将确保到服务的连接可跨提供服务的容器实现负载均衡。服务的IP地址保持不变，因此客户端始终可以连接到它的容器，即使它们在集群中移动。&lt;/p&gt;
&lt;p&gt;如果在所有服务器上部署了Kubernetes，那么运维团队就不需要再部署应用程序。因为容器化的应用程序已经包含了运行所需的所有内 容，系统管理员不需要安装任何东西来部署和运行应用程序。在任何部署Kubernetes的节点上，Kubernetes可以在不需要系统管理员任何帮助的情况下立即运行应用程序。 简化应用程序部署由于Kubernetes将其所有工作节点公开为一个部署平台，因此应用程序开发人员可以自己开始部署应用程序，不需要了解组成集群的服务器。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mysql innoDB事务隔离性</title>
      <link>http://chaoxin.site/post/innodb_transaction/</link>
      <pubDate>Sun, 05 Feb 2023 23:59:27 +0800</pubDate>
      
      <guid>http://chaoxin.site/post/innodb_transaction/</guid>
      <description>&lt;h2 id=&#34;事务有哪些特性&#34;&gt;事务有哪些特性？&lt;/h2&gt;
&lt;p&gt;并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务
事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原子性（Atomicity）&lt;/strong&gt;：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，如果事务在执行过程中发生错误，会被回滚到事务开始前的状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性（Isolation）&lt;/strong&gt;：数据库允许多个并发事务同时对其数据进行读写和修改的能力，不同隔离级别事务之间的相关干扰的程度也是不一样的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性（Durability）&lt;/strong&gt;：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;持久性是通过 redo log （重做日志）来保证的，重做日志保证事务提交后的正确执行，一般&lt;strong&gt;用于掉电等故障恢复&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;原子性是通过 undo log（回滚日志） 来保证的，事务如果没有正常提交，则进行回滚&lt;/li&gt;
&lt;li&gt;隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；&lt;/li&gt;
&lt;li&gt;一致性则是通过持久性+原子性+隔离性来保证；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;并行事务会引发什么问题&#34;&gt;并行事务会引发什么问题？&lt;/h2&gt;
&lt;h3 id=&#34;脏读&#34;&gt;脏读&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;不可重复读&#34;&gt;不可重复读&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;幻读&#34;&gt;幻读&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在同一事务中，多次查询的读必须是同种类型的读，不同类型的读的用法是不正确的也是无法避免上述问题的。
如：同一个事务中，如果不对数据做修改，用select时则应该用普通select；反之，如果要对相关数据修改且要用select，则应该用当前读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;读的类型&#34;&gt;读的类型&lt;/h2&gt;
&lt;h3 id=&#34;快照读&#34;&gt;快照读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不加锁的select操作（注：事务级别不是串行化）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;当前读&#34;&gt;当前读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;select lock in share mode (共享锁)&lt;/li&gt;
&lt;li&gt;select for update (排他锁)&lt;/li&gt;
&lt;li&gt;update (排他锁)&lt;/li&gt;
&lt;li&gt;insert (排他锁)&lt;/li&gt;
&lt;li&gt;delete (排他锁)&lt;/li&gt;
&lt;li&gt;串行化事务隔离级别&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;SELECT &amp;hellip; LOCK IN SHARE MODE的应用场景：
适合于两张表存在关系时的写操作，拿mysql官方文档的例子来说，一个表是child表，一个是parent表，假设child表的某一列child_id映射到parent表的c_child_id列，那么从业务角度讲，此时我直接insert一条child_id=100记录到child表是存在风险的，因为刚insert的时候可能在parent表里删除了这条c_child_id=100的记录，那么业务数据就存在不一致的风险。正确的方法是再插入时执行select * from parent where c_child_id=100 lock in share mode,锁定了parent表的这条记录，然后执行insert into child(child_id) values (100)就ok了。
原文链接：&lt;a href=&#34;https://blog.csdn.net/cug_jiang126com/article/details/50544728&#34;target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;https://blog.csdn.net/cug_jiang126com/article/details/50544728&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;不同隔离级别如何解决问题&#34;&gt;不同隔离级别如何解决问题&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;隔离级别&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;存在问题&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;解决方式&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读未提交&lt;/td&gt;
&lt;td&gt;脏读、不可重读、幻读&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;读提交&lt;/td&gt;
&lt;td&gt;不可重读、幻读&lt;/td&gt;
&lt;td&gt;MVCC（快照读）+ 读写锁（当前读）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;MVCC（快照读）+ next-key lock（当前读）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;串行化&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;读写锁（快照读+当前读）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;读提交&#34;&gt;读提交&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;快照读：在该隔离级别下，两个事务的快照读在MVCC的作用下，根据事务的版本号，不会读到其他事务未提交的数据，解决了脏读（两个事务间的读写冲突），读相同数据时，也不会阻塞（两个事务间的读写冲突读读冲突）&lt;/li&gt;
&lt;li&gt;当前读：在该隔离级别下，两个事务的当前读需要对加对应的读写锁，在修改数据时，没有锁的事务会被阻塞（写写冲突）。但是会出现幻读，因为锁只锁住了存在的数据，如果另外一个事务添加了数据并提交了事务，再次当前读会读到刚刚添加的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;可重复读&#34;&gt;可重复读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;快照读：在该隔离级别下，两个事务的快照读在MVCC的作用下，根据事务的版本号，不会读到其他事务未提交的数据，解决了脏读（两个事务间的读写冲突），读相同数据时，也不会阻塞（两个事务间的读写冲突读读冲突）&lt;/li&gt;
&lt;li&gt;当前读：在该隔离级别下，两个事务的当前读需要对加对应的临间锁（next-key lock），在修改数据时，没有锁的事务会被阻塞（写写冲突）。当前读不会再出现幻读，因为临间锁不仅锁住了存在的数据，还锁住了数据的区间，如果其他事务添加数据，因为当前区间被锁住了，所以会被阻塞住&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;参考：
&lt;a href=&#34;https://juejin.cn/post/7134186501306318856&#34;target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;https://juejin.cn/post/7134186501306318856&lt;/a&gt;

&lt;a href=&#34;https://juejin.cn/post/7134186501306318856&#34;target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;https://xiaolincoding.com/mysql/transaction/mvcc.html#%E8%AF%BB%E6%8F%90%E4%BA%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84&lt;/a&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>初探内存泄露</title>
      <link>http://chaoxin.site/post/memory_leak/</link>
      <pubDate>Tue, 23 Aug 2022 12:07:24 +0800</pubDate>
      
      <guid>http://chaoxin.site/post/memory_leak/</guid>
      <description>&lt;h2 id=&#34;1定义&#34;&gt;1.定义&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;内存泄露 memory leak&lt;/strong&gt; ，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但持续累积，内存打满以后，服务将会崩溃。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;监控实例：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://s2.loli.net/2022/08/24/eh9W7GMHmpfIRKT.png&#34;
        alt=&#34;image 3.png&#34;/&gt;&lt;/p&gt;
&lt;p&gt;正常的内存监控曲线应该稳定在一个区间内起伏。而内存泄露后，可以看到，内存一直都在上涨，在打满后，实例直接崩溃重启，然后又重新打满，又重启，如此循环。&lt;/p&gt;
&lt;h2 id=&#34;2内存泄露的常见原因&#34;&gt;2.内存泄露的常见原因&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;全局变量应该释放的内存没有被释放，全局变量的内存一直增长(正常应该有释放有增长)，如map的kv一直在增加、切片的长度一直在增长&lt;/li&gt;
&lt;li&gt;需要close的变量没有被关闭，如http 链接、mysql链接&lt;/li&gt;
&lt;li&gt;goroutine 泄露，原本应该结束的goroutine没有结束，导致对应的内存无法被释放&lt;/li&gt;
&lt;li&gt;Cgo 相关的内存泄露，在Go里使用Cgo，C代码分配的内存是无法被Go的GC管理的，也无法被pprof追踪&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3使用pprof&#34;&gt;3.使用pprof&lt;/h2&gt;
&lt;h3 id=&#34;pprof介绍&#34;&gt;pprof介绍&lt;/h3&gt;
&lt;p&gt;pprof是 Go 语言中分析程序运行性能的工具，它能提供各种性能数据：&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://s2.loli.net/2022/08/24/bE7CRUJfQpKOeua.png&#34;
        alt=&#34;image 4.png&#34;/&gt;&lt;/p&gt;
&lt;h3 id=&#34;建议排查步骤&#34;&gt;建议排查步骤&lt;/h3&gt;
&lt;h4 id=&#34;一检查代码&#34;&gt;一.检查代码&lt;/h4&gt;
&lt;p&gt;查看全局变量是否有可疑逻辑，导致全局变量内存不断增长&lt;/p&gt;
&lt;p&gt;查看是否有没有关闭的&lt;em&gt;&lt;strong&gt;close&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;查看&lt;strong&gt;Cgo&lt;/strong&gt; &lt;strong&gt;相关代码&lt;/strong&gt;，如CString的内存有没有被释放&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt; 函数使用CString匿名参数，也会导致内存泄露&lt;/p&gt;
&lt;p&gt;问题代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;get_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;content&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;40960&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;errmsg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1024&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;修复后：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;cfile&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;ckey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;get_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cfile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ckey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;content&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;40960&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;errmsg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1024&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cfile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ckey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;等等其他可能造成内存泄露的代码&lt;/p&gt;
&lt;h4 id=&#34;二查看goroutine是否泄露&#34;&gt;二.查看goroutine是否泄露&lt;/h4&gt;
&lt;p&gt;压测过程中，使用 &lt;em&gt;&lt;strong&gt;pprof&lt;/strong&gt;&lt;/em&gt; ，访问 （对应的IP和端口）&lt;a href=&#34;http://10.12.205.56:8305/debug/pprof/goroutine?debug=1&#34;target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;http://127.0.0.1:8305/debug/pprof/goroutine?debug=1&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;查看goroutine数量是否稳定在一个区间：&lt;/p&gt;
&lt;p&gt;如果goroutine不断增长，确定为&lt;em&gt;&lt;strong&gt;goroutine&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;泄露&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;三查看实时内存&#34;&gt;三.查看实时内存&lt;/h4&gt;
&lt;p&gt;压测过程中，当内存达到一个高值以后，使用命令 （对应IP和端口）&lt;/p&gt;
&lt;p&gt;生成实时内存数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go tool pprof http://127.0.0.1:8080/debug/pprof/heap?debug&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装并使用graphviz 绘制对应的图形&lt;/p&gt;
&lt;p&gt;使用命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go tool pprof http://127.0.0.1:8080/debug/pprof/heap?debug&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;访问 &lt;a href=&#34;http://127.0.0.1:8090/ui&#34;target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;http://127.0.0.1:8090/ui&lt;/a&gt;
 查看内存路线图和火焰图，帮助定位问题&lt;/p&gt;
&lt;p&gt;火焰图的查看方法为：从上到下为调用链路，左右间距越大标识占用内存越多&lt;/p&gt;
&lt;h4 id=&#34;四查看累积内存&#34;&gt;四.查看累积内存&lt;/h4&gt;
&lt;p&gt;如果实时内存无法定位问题，可以查看累积时间申请的内存，帮助定位问题&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go tool pprof http://127.0.0.1:8080/debug/pprof/heap -seconds &lt;span class=&#34;m&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4内存监控&#34;&gt;4.内存监控&lt;/h2&gt;
&lt;p&gt;没有对应的内存监控工具，可以使用命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ps aux &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep 对应pid
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看&lt;strong&gt;RSS&lt;/strong&gt;查看实时占用内存&lt;/p&gt;
&lt;h2 id=&#34;5查看gc&#34;&gt;5.查看GC&lt;/h2&gt;
&lt;p&gt;查看GC是否正常，使用命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;GODEBUG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;gctrace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; go run main.go
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>做笔记的心得体会</title>
      <link>http://chaoxin.site/post/writing_skill/</link>
      <pubDate>Sat, 04 Jun 2022 14:28:33 +0800</pubDate>
      
      <guid>http://chaoxin.site/post/writing_skill/</guid>
      <description>&lt;h2 id=&#34;1前言&#34;&gt;1.前言&lt;/h2&gt;
&lt;p&gt;前前后后试过多种笔记的记录方式，包括博客形式、单纯的markdown形式、有道云笔记的形式等等，最后还是回归博客的形式。&lt;/p&gt;
&lt;p&gt;主要理由是笔记其实大部分情况下是写给自己看的，如果笔记的形式自己都不想去看第二遍的话，那写笔记就显得没有意义。博客的好处是比较定制化、美观，自己更有意愿去看。&lt;/p&gt;
&lt;h2 id=&#34;2排版的心得&#34;&gt;2.排版的心得&lt;/h2&gt;
&lt;p&gt;做笔记的排版是很重要的，直接影响阅读体验。之前有些时候做的笔记第一遍看起来还可以，但是过了一段时间再去看简直惨不忍睹。&lt;/p&gt;
&lt;p&gt;在看了很多优秀的博文、公众号推送等文章后，总结出排版的心得：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前言是需要的，可以表明写这篇笔记的背景、场景、目的，方便后续阅读和修改。&lt;/li&gt;
&lt;li&gt;不要有太多的代码块，如果有太多的代码应该放在代码库里，而不是放在笔记里&lt;/li&gt;
&lt;li&gt;尽量多用有序列表少用无序列表&lt;/li&gt;
&lt;li&gt;引用里不要放太多内容，最多不要超过3行&lt;/li&gt;
&lt;li&gt;总结在大部分情况下是需要的&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3内容的心得&#34;&gt;3.内容的心得&lt;/h2&gt;
&lt;p&gt;做笔记的内容是笔记的核心，很多内容其实并不适合做成笔记的形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单的内容就不要写成笔记了，至少有一些深入才适合做笔记。如语法、Api、基本概念或者一些基本的使用，这些内容不如直接google来的实在&lt;/li&gt;
&lt;li&gt;尽量多画图，流程图、泳道图、思维导图等等，画一张图胜过写10行内容&lt;/li&gt;
&lt;li&gt;不要抄别人的笔记然后略做修改就变成自己的笔记了，浪费时间&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>